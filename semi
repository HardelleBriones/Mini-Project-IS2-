import pandas as pd
import re
import tensorflow_hub as hub
from sklearn.metrics.pairwise import cosine_similarity
from bs4 import BeautifulSoup
import urllib.request
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
from sklearn.feature_extraction.text import TfidfVectorizer
import tkinter as tk
from tkinter.scrolledtext import ScrolledText
import nltk

nltk.download('stopwords')
nltk.download('wordnet')

module_url = r'C:\Users\Gabriel\Desktop\VS Code\miniproj'
model = hub.load(module_url)

def preprocess_text(text, remove_tags=False):
    if remove_tags:
        soup = BeautifulSoup(text, "html.parser")
        text = soup.get_text()

    text = text.lower()
    tokens = text.split()
    stop_words = set(stopwords.words("english"))
    tokens = [word for word in tokens if word not in stop_words]
    lemmatizer = WordNetLemmatizer()
    tokens = [lemmatizer.lemmatize(word) for word in tokens]
    processed_text = " ".join(tokens)
    return processed_text

url = 'https://drive.google.com/u/0/uc?id=1tyy8KC1JCCBEJ22VMxeYNso8LKjP7Ta3&export=download'
csv_file_path = 'question_data.csv'
urllib.request.urlretrieve(url, csv_file_path)

question_data = pd.read_csv(csv_file_path)
question_texts = question_data['question_title'].apply(preprocess_text)
vectorizer = TfidfVectorizer()
question_vectors = vectorizer.fit_transform(question_texts)

def format_paragraphs(text, words_per_line=10):
    words = text.split()
    lines = [' '.join(words[i:i+words_per_line]) for i in range(0, len(words), words_per_line)]
    return '\n'.join(lines)

def toggle_answer(question_answer):
    answer_window = tk.Toplevel(root)
    answer_text = ScrolledText(answer_window, wrap="word", height=8, width=90, font=font_style, state=tk.NORMAL)
    answer_text.insert(tk.END, question_answer)
    answer_text.configure(state=tk.DISABLED)
    answer_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    hide_button = tk.Button(answer_window, text="Hide Answer", command=answer_window.destroy, bg=btn_color, fg=font_color, font=font_style)
    hide_button.pack()

def update_results():
    user_input = search_entry.get()
    user_input = preprocess_text(user_input)
    user_input_vector = vectorizer.transform([user_input])
    similarities = cosine_similarity(user_input_vector, question_vectors)[0]
    k = 5
    top_k_indices = similarities.argsort()[::-1][:k]
    for widget in result_frame.winfo_children():
        widget.destroy()
    for i, index in enumerate(top_k_indices):
        if similarities[index] <= 0.40:
            break
        question_title = question_data.loc[index, 'question_title']
        question_body = format_paragraphs(preprocess_text(question_data.loc[index, 'question_body'], remove_tags=True))
        question_answer = format_paragraphs(preprocess_text(question_data.loc[index, 'answer_body'], remove_tags=True))

        title_label = tk.Label(result_frame, text=f"Question {i+1}: {question_title}", font=font_style, fg=font_color, bg=bg_color, padx=10, pady=10, wraplength=700, justify='center')
        title_label.pack(fill=tk.X, padx=120, pady=10, anchor='center')

        body_text = ScrolledText(result_frame, height=8, width=70, font=font_style, state=tk.NORMAL)
        body_text.insert(tk.END, question_body)
        body_text.configure(state=tk.DISABLED)
        body_text.pack(pady=20, padx=120, expand=True, fill=tk.X, anchor='center')

        toggle_button = tk.Button(result_frame, text="Show Answer", command=lambda current_answer=question_answer: toggle_answer(current_answer), bg=btn_color, fg=font_color, font=font_style)
        toggle_button.pack(pady=10, padx=120, anchor='center')

        spacer_label = tk.Label(result_frame, text="", bg=bg_color, height=2)  
        spacer_label.pack()

root = tk.Tk()
root.title("Search Engine")  
root.geometry("900x700")

bg_color = "#D6EAF8"
btn_color = "#3498DB"
font_color = "#283747"
highlight_font_color = "#C0392B"
font_style = ("Helvetica", 12)
root.configure(bg=bg_color)

title_label = tk.Label(root, text="Unsay Title?", font=("Helvetica", 28, "bold"), fg=highlight_font_color, bg=bg_color)
title_label.pack(pady=10)

search_frame = tk.Frame(root, bg=bg_color)
search_frame.pack(pady=20)

search_entry = tk.Entry(search_frame, width=60, font=font_style)  
search_entry.pack(side=tk.LEFT, padx=10)

search_button = tk.Button(search_frame, text="Search", command=update_results, bg=btn_color, fg=font_color, font=font_style)
search_button.pack(side=tk.LEFT, padx=10)

canvas = tk.Canvas(root, bg=bg_color)
scrollbar = tk.Scrollbar(root, command=canvas.yview)
canvas.configure(yscrollcommand=scrollbar.set)
scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

result_frame = tk.Frame(canvas, bg=bg_color)  
result_frame.pack(fill='both', expand=True)

canvas_window = canvas.create_window((0, 0), window=result_frame, anchor='nw')

def on_frame_configure(canvas):
    canvas.configure(scrollregion=canvas.bbox("all"))

result_frame.bind("<Configure>", lambda event, canvas=canvas: on_frame_configure(canvas))

root.mainloop()